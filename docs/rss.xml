<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Kylin's</title><link>https://kylinholmes.github.io</link><description>Essay</description><copyright>Kylin's</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/45586871?v=4</url><title>avatar</title><link>https://kylinholmes.github.io</link></image><lastBuildDate>Thu, 07 Nov 2024 16:20:38 +0000</lastBuildDate><managingEditor>Kylin's</managingEditor><ttl>60</ttl><webMaster>Kylin's</webMaster><item><title>Native 和 Uniapp的 双向通信</title><link>https://kylinholmes.github.io/post/Native%20-he-%20Uniapp-de-%20-shuang-xiang-tong-xin.html</link><description>主要思路：&#13;
1. FFI： 通过ABI接口把数据传输到 Uniapp&#13;
2. 直接通过发送消息的接口发送数据&#13;
&#13;
其中1在安卓的接口中是确实支持的，在IOS中暂时没看到相关接口&#13;
Android: [DCUniMPJSCallback.invoke(data)](https://nativesupport.dcloud.net.cn/UniMPDocs/API/android-v2.html#dcunimpjscallback-invoke)&#13;
&#13;
**考虑到统一，可以考虑用方案2，通过发送event**&#13;
&#13;
## Native到 Uniapp&#13;
&gt; 宿主主动触发事件到正在运行的小程序。</description><guid isPermaLink="true">https://kylinholmes.github.io/post/Native%20-he-%20Uniapp-de-%20-shuang-xiang-tong-xin.html</guid><pubDate>Thu, 07 Nov 2024 15:53:18 +0000</pubDate></item><item><title>不要再使用CentOS系的发行版 作为运行和开发环境</title><link>https://kylinholmes.github.io/post/bu-yao-zai-shi-yong-CentOS-xi-de-fa-xing-ban-%20-zuo-wei-yun-xing-he-kai-fa-huan-jing.html</link><description>## CentOS本身不再维护&#13;
因为不再维护，部分镜像源仓库（清华源） 开始停止服务。</description><guid isPermaLink="true">https://kylinholmes.github.io/post/bu-yao-zai-shi-yong-CentOS-xi-de-fa-xing-ban-%20-zuo-wei-yun-xing-he-kai-fa-huan-jing.html</guid><pubDate>Wed, 11 Sep 2024 06:06:27 +0000</pubDate></item><item><title>Application Binary Interface</title><link>https://kylinholmes.github.io/post/Application%20Binary%20Interface.html</link><description>&#13;
**ABI 大致包含以下内容**&#13;
~~Todo: ~~&#13;
- [ ] 函数调用：&#13;
- [ ] 数据类型布局：&#13;
- [ ] 异常处理：&#13;
- [ ] 内存管理：&#13;
- [ ] 命名重整（Name Mangling）：&#13;
- [ ] 类型转换：&#13;
- [ ] 线程机制：&#13;
- [ ] 动态链接：&#13;
&#13;
 &#13;
## 函数调用&#13;
  - 参数传递：规定了函数参数是如何传递的，包括参数的顺序、位置（寄存器或栈）等。</description><guid isPermaLink="true">https://kylinholmes.github.io/post/Application%20Binary%20Interface.html</guid><pubDate>Fri, 23 Aug 2024 03:46:26 +0000</pubDate></item><item><title>在 Rust中 动态链接和运行时加载动态库</title><link>https://kylinholmes.github.io/post/zai-%20Rust-zhong-%20-dong-tai-lian-jie-he-yun-xing-shi-jia-zai-dong-tai-ku.html</link><description>## 动态链接crate&#13;
&#13;
**假设动态库是 impls**&#13;
**需要链接到 impls的crate是abi**&#13;
&#13;
```bash&#13;
├── abi                     # runtime loading library&#13;
│  ├── Cargo.toml           # specifies dependent libraries to be used for dynamic linking&#13;
│  └── src&#13;
│     ├── import.rs         # import impls to this crate&#13;
│     ├── lib.rs            # &#13;
│     └── main.rs           # test main: loading abi and binding interface&#13;
├── impls                   # dynamic link library &#13;
│  └── src&#13;
│     └── lib.rs            # impls&#13;
└── README.md&#13;
```&#13;
&#13;
`main` == loadl ibrary =&gt; `abi` == dynamic link ==&gt; `impls`&#13;
&#13;
设置lib类型为`cdylib`&#13;
```toml&#13;
# impls/Cargo.toml&#13;
[lib]&#13;
crate-type = ['cdylib']&#13;
```&#13;
&#13;
导出接口&#13;
```rust&#13;
// impls/src/lib.rs&#13;
#[no_mangle]&#13;
pub extern 'C' fn add(left: usize, right: usize) -&gt; usize {&#13;
    left + right&#13;
}&#13;
```&#13;
&#13;
&#13;
&#13;
设置依赖 &#13;
```toml&#13;
# abi/Cargo.toml&#13;
[dependencies]&#13;
impls = { path = '../impls' }&#13;
```&#13;
&#13;
接口定义&#13;
```rust&#13;
#[link(name = 'impls')]&#13;
extern 'C' {&#13;
    pub fn add(a :usize, b: usize) -&gt; usize;&#13;
}&#13;
```&#13;
&#13;
调用接口&#13;
```rust&#13;
println!('Add {}', add(1, 9));&#13;
```&#13;
&#13;
## 运行时加载动态库&#13;
因为是运行时加载，所以函数的接口不需要单独定义，通常是绑定到函数指针上&#13;
&#13;
```toml&#13;
# abi/Cargo.toml&#13;
[dependencies]&#13;
impls = { path = '../impls' }&#13;
libloading = '0.8.5'&#13;
```&#13;
&#13;
```rust&#13;
// abi/src/main.rs&#13;
use libloading::{Library, Symbol};&#13;
&#13;
static DLL_HANDLE:Lazy&lt;Library&gt; = Lazy::new(|| {&#13;
    unsafe {&#13;
        let dll = std::env::args().nth(1).expect('No DLL provided');&#13;
        Library::new(dll).expect('Failed to load DLL')&#13;
    }&#13;
});&#13;
&#13;
// 定义好函数指针的结构体&#13;
#[derive(Debug)]&#13;
struct Interface&lt;'a&gt; {&#13;
    add: Symbol&lt;'a, extern 'C' fn(usize, usize) -&gt; usize&gt;,&#13;
    init: Symbol&lt;'a, extern 'C' fn() -&gt; ()&gt;,&#13;
}&#13;
&#13;
// 加载动态库后，绑定函数指针&#13;
impl &lt;'a&gt; Interface&lt;'a&gt; {&#13;
    fn new() -&gt; Self {&#13;
        unsafe {&#13;
            let add: Symbol&lt;extern 'C' fn(usize, usize) -&gt; usize&gt; = DLL_HANDLE.borrow().get(b'add').expect('Failed to load add');&#13;
            let init: Symbol&lt;extern 'C' fn() -&gt; ()&gt; = DLL_HANDLE.borrow().get(b'init').expect('Failed to load init');&#13;
            Interface {&#13;
                add,&#13;
                init&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
fn main() {&#13;
    let handle = Interface::new();&#13;
    (handle.init)();&#13;
    let result = (handle.add)(1, 9);&#13;
    println!('Result: {}', result);&#13;
    &#13;
}&#13;
&#13;
```&#13;
&#13;
&#13;
## Demo&#13;
项目地址 [Demo](https://github.com/kylinholmes/rs_dynamic_link)。</description><guid isPermaLink="true">https://kylinholmes.github.io/post/zai-%20Rust-zhong-%20-dong-tai-lian-jie-he-yun-xing-shi-jia-zai-dong-tai-ku.html</guid><pubDate>Mon, 12 Aug 2024 04:47:59 +0000</pubDate></item><item><title>This is a Title</title><link>https://kylinholmes.github.io/post/This%20is%20a%20Title.html</link><description># Head 1&#13;
some text。</description><guid isPermaLink="true">https://kylinholmes.github.io/post/This%20is%20a%20Title.html</guid><pubDate>Fri, 21 Jun 2024 16:03:02 +0000</pubDate></item></channel></rss>